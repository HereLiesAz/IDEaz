package com.hereliesaz.ideaz.buildlogic

import com.hereliesaz.ideaz.IBuildCallback
import java.io.File
import java.io.FileInputStream
import java.io.FileOutputStream
import java.util.zip.ZipEntry
import java.util.zip.ZipFile
import java.util.zip.ZipOutputStream

/**
 * A [BuildStep] that constructs the final unsigned APK by merging various components.
 *
 * **Role:**
 * This step acts as the "APK Builder" (analogous to `apkbuilder` or `zip` in traditional toolchains).
 * It merges:
 * 1.  **Resources APK:** Generated by `Aapt2Link` (contains `AndroidManifest.xml`, `resources.arsc`, and compiled resources).
 * 2.  **DEX Files:** Generated by `D8Compile` (`classes.dex`).
 * 3.  **Native Libraries:** Extracted from AARs or source (`lib/{abi}/*.so`).
 * 4.  **Java Assets:** (`assets/` directory).
 *
 * **Critical details:**
 * - Maintains correct compression settings (e.g., `resources.arsc` MUST be `STORED`/Uncompressed).
 * - Filters duplicate files during the merge.
 */
class ApkBuild(
    private val finalApkPath: String,
    private val resourcesApkPath: String,
    private val classesDir: String,
    private val jniLibsDir: String? = null,
    private val assetsDir: String? = null
) : BuildStep {

    override fun execute(callback: IBuildCallback?): BuildResult {
        try {
            // Verify Dex existence
            val dexFile = File(classesDir, "classes.dex")
            if (!dexFile.exists()) {
                val error = "classes.dex not found at ${dexFile.absolutePath}!"
                callback?.onLog(error)
                return BuildResult(false, error)
            }

            // Ensure we are creating a fresh file.
            File(finalApkPath).delete()

            // Safe Merge Strategy:
            // 1. Open Output Stream (final APK)
            // 2. Read Resources APK (base) -> Copy entries
            // 3. Add classes.dex
            // 4. Add Native Libs (if provided)
            // 5. Add Extra Assets (if provided)

            val zos = ZipOutputStream(FileOutputStream(finalApkPath))
            zos.use { out ->
                // 1. Copy everything from resources.apk (AndroidManifest.xml, resources.arsc, res/**/*)
                val resApk = File(resourcesApkPath)
                if (resApk.exists()) {
                    ZipFile(resApk).use { zip ->
                        zip.entries().asSequence().forEach { entry ->
                            // Avoid duplicates if classes.dex or libs exist in base (unlikely from AAPT2, but safe)
                            if (entry.name == "classes.dex" || entry.name.startsWith("lib/")) {
                                return@forEach
                            }

                            // Important: Preserve compression method (STORED vs DEFLATED)
                            // resources.arsc MUST be STORED (uncompressed) so Android can mmap it.
                            // If it is compressed, Android Package Manager will reject the APK during install.
                            val newEntry = ZipEntry(entry.name)
                            if (entry.method == ZipEntry.STORED) {
                                newEntry.method = ZipEntry.STORED
                                newEntry.size = entry.size
                                newEntry.compressedSize = entry.size
                                newEntry.crc = entry.crc
                            } else {
                                newEntry.method = ZipEntry.DEFLATED // Default for everything else
                            }

                            out.putNextEntry(newEntry)
                            zip.getInputStream(entry).use { it.copyTo(out) }
                            out.closeEntry()
                        }
                    }
                }

                // 2. Add classes.dex
                // classes.dex is usually DEFLATED, which is default for new ZipEntry
                val dexEntry = ZipEntry("classes.dex")
                out.putNextEntry(dexEntry)
                FileInputStream(dexFile).use { it.copyTo(out) }
                out.closeEntry()

                // 3. Add Native Libs (lib/{abi}/*.so)
                if (jniLibsDir != null) {
                    val libDir = File(jniLibsDir)
                    if (libDir.exists()) {
                        libDir.walkTopDown().filter { it.isFile }.forEach { file ->
                            val relativePath = file.relativeTo(libDir).path.replace("\\", "/")
                            val zipPath = "lib/$relativePath"

                            // Note on Native Lib Compression:
                            // If 'extractNativeLibs=true' in Manifest (default < M), libs can be compressed.
                            // If 'extractNativeLibs=false', libs MUST be page-aligned and uncompressed.
                            // Currently, we rely on the default behavior (likely extracted), so compression is fine.
                            // Optimization TODO: Implement uncompressed storage + alignment for API 23+

                            out.putNextEntry(ZipEntry(zipPath))
                            FileInputStream(file).use { it.copyTo(out) }
                            out.closeEntry()
                        }
                    }
                }

                // 4. Add Extra Assets (assets/...)
                if (assetsDir != null) {
                    val assetRoot = File(assetsDir)
                    if (assetRoot.exists()) {
                        assetRoot.walkTopDown().filter { it.isFile }.forEach { file ->
                            val relativePath = file.relativeTo(assetRoot).path.replace("\\", "/")
                            val zipPath = "assets/$relativePath"
                            out.putNextEntry(ZipEntry(zipPath))
                            FileInputStream(file).use { it.copyTo(out) }
                            out.closeEntry()
                        }
                    }
                }
            }

            val successMessage = "APK built successfully with merged components."
            callback?.onLog(successMessage)
            return BuildResult(true, successMessage)

        } catch (e: Exception) {
            e.printStackTrace()
            val errorMessage = "APK Build Failed: ${e.message}"
            callback?.onLog(errorMessage)
            return BuildResult(false, errorMessage)
        }
    }
}
